import 'dart:typed_data';

import 'package:flat_buffers/flat_buffers.dart' as fb;
import 'package:objectbox/objectbox.dart';
import 'package:objectbox_flutter_libs/objectbox_flutter_libs.dart';

import '../../../models/category/category_model.dart';
import '../../../models/chapter/chapter_model.dart';
import '../../../models/extension/extension_model.dart';
import '../../../models/manga/manga_model.dart';
import '../../../models/source/source_model.dart';
import '../../../relations/manga_chapter/manga_chapter_relation.dart';

// GENERATED CODE - DO NOT MODIFY BY HAND
// This code was generated by ObjectBox. To update it run the generator again:
// With a Flutter package, run `flutter pub run build_runner build`.
// With a Dart package, run `dart run build_runner build`.
// See also https://docs.objectbox.io/getting-started#generate-objectbox-code

// ignore_for_file: camel_case_types

import 'package:objectbox/internal.dart'; // generated code can access "internal" functionality

export 'package:objectbox/objectbox.dart'; // so that callers only have to import this file

final _entities = <ModelEntity>[
  ModelEntity(
      id: const IdUid(1, 2090354631594225125),
      name: 'Category',
      lastPropertyId: const IdUid(4, 3921391533582899518),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 8363760434705411795),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 2567337692776450494),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 2739678048181348958),
            name: 'order',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 3921391533582899518),
            name: 'defaultCategory',
            type: 1,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(2, 7307524957794958371),
      name: 'Chapter',
      lastPropertyId: const IdUid(17, 620406828435301553),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 2802040182618943909),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 8126604582416613264),
            name: 'bookmarked',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 386574432027639742),
            name: 'chapterCount',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 5843347549335818962),
            name: 'chapterNumber',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 3634576483305611987),
            name: 'downloaded',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 2998370678612386012),
            name: 'fetchedAt',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 7959418752543153642),
            name: 'index',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 3113127710730504916),
            name: 'markPrevRead',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(9, 6458292218479253990),
            name: 'lastPageRead',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(10, 6921072674312490539),
            name: 'lastReadAt',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(11, 676731410156747809),
            name: 'mangaId',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(12, 2604200807635587073),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(13, 807770657875482147),
            name: 'pageCount',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(14, 2031387676177408990),
            name: 'read',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(15, 3795291461559483740),
            name: 'scanlator',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(16, 7392193483472929455),
            name: 'uploadDate',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(17, 620406828435301553),
            name: 'url',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(3, 4798098575857622302),
      name: 'Extension',
      lastPropertyId: const IdUid(12, 8795788377641220788),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 6769901752037726937),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 3688541291110974759),
            name: 'apkName',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 8473980306491942193),
            name: 'iconUrl',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 3398055118107026415),
            name: 'name',
            type: 9,
            flags: 2048,
            indexId: const IdUid(1, 4993312559171509448)),
        ModelProperty(
            id: const IdUid(5, 1455167966460366948),
            name: 'pkgName',
            type: 9,
            flags: 2080,
            indexId: const IdUid(2, 3614419234424462395)),
        ModelProperty(
            id: const IdUid(6, 989323907394221620),
            name: 'versionName',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 6457783978847420045),
            name: 'versionCode',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 5970383663812628801),
            name: 'lang',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(9, 3074741900962130198),
            name: 'isNsfw',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(10, 5100820328888158987),
            name: 'installed',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(11, 4133961520258564356),
            name: 'hasUpdate',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(12, 8795788377641220788),
            name: 'obsolete',
            type: 1,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(4, 6666782116779621245),
      name: 'Manga',
      lastPropertyId: const IdUid(17, 4455286572496529666),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 3057779884994909057),
            name: 'artist',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(2, 2296756496242059769),
            name: 'author',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 205709376540943310),
            name: 'description',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 2135830204827558666),
            name: 'downloadCount',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 8672874531463701987),
            name: 'freshData',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 5952096618106609648),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(7, 3521114205281021025),
            name: 'inLibrary',
            type: 1,
            flags: 8,
            indexId: const IdUid(3, 1556590793078793804)),
        ModelProperty(
            id: const IdUid(8, 2665622925253260257),
            name: 'inLibraryAt',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(9, 5371565745356851653),
            name: 'initialized',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(10, 6419839100747214589),
            name: 'realUrl',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(11, 9168274279453933692),
            name: 'sourceId',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(12, 7805053381919076087),
            name: 'status',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(13, 3415823536129673988),
            name: 'thumbnailUrl',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(14, 3163696221236622000),
            name: 'title',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(15, 6351601349220207150),
            name: 'unreadCount',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(16, 540447377578391223),
            name: 'url',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(17, 4455286572496529666),
            name: 'genre',
            type: 30,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(5, 1640842792046881409),
      name: 'MangaChapterRelation',
      lastPropertyId: const IdUid(2, 5830679700909367282),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 5460212575770570010),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 5830679700909367282),
            name: 'mangaId',
            type: 11,
            flags: 520,
            indexId: const IdUid(4, 8232055663794495718),
            relationTarget: 'Manga')
      ],
      relations: <ModelRelation>[
        ModelRelation(
            id: const IdUid(1, 1885848043178191775),
            name: 'chapters',
            targetId: const IdUid(2, 7307524957794958371))
      ],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(6, 2677398056744556828),
      name: 'Source',
      lastPropertyId: const IdUid(9, 8815817972390227025),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 1090831279669418015),
            name: 'intId',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 7535835199043313992),
            name: 'id',
            type: 9,
            flags: 2080,
            indexId: const IdUid(5, 6602405433480440205)),
        ModelProperty(
            id: const IdUid(3, 5343170028039869280),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 6032128572368597203),
            name: 'lang',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 4279063945406374282),
            name: 'iconUrl',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 3033610657893057706),
            name: 'supportsLatest',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 1322957490967427170),
            name: 'isConfigurable',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 4671313769765243261),
            name: 'isNsfw',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(9, 8815817972390227025),
            name: 'displayName',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[])
];

/// Open an ObjectBox store with the model declared in this file.
Future<Store> openStore(
        {String? directory,
        int? maxDBSizeInKB,
        int? fileMode,
        int? maxReaders,
        bool queriesCaseSensitiveDefault = true,
        String? macosApplicationGroup}) async =>
    Store(getObjectBoxModel(),
        directory: directory ?? (await defaultStoreDirectory()).path,
        maxDBSizeInKB: maxDBSizeInKB,
        fileMode: fileMode,
        maxReaders: maxReaders,
        queriesCaseSensitiveDefault: queriesCaseSensitiveDefault,
        macosApplicationGroup: macosApplicationGroup);

/// ObjectBox model definition, pass it to [Store] - Store(getObjectBoxModel())
ModelDefinition getObjectBoxModel() {
  final model = ModelInfo(
      entities: _entities,
      lastEntityId: const IdUid(6, 2677398056744556828),
      lastIndexId: const IdUid(5, 6602405433480440205),
      lastRelationId: const IdUid(1, 1885848043178191775),
      lastSequenceId: const IdUid(0, 0),
      retiredEntityUids: const [],
      retiredIndexUids: const [],
      retiredPropertyUids: const [],
      retiredRelationUids: const [],
      modelVersion: 5,
      modelVersionParserMinimum: 5,
      version: 1);

  final bindings = <Type, EntityDefinition>{
    Category: EntityDefinition<Category>(
        model: _entities[0],
        toOneRelations: (Category object) => [],
        toManyRelations: (Category object) => {},
        getId: (Category object) => object.id,
        setId: (Category object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Category.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Category object, fb.Builder fbb) {
          final nameOffset =
              object.name == null ? null : fbb.writeString(object.name!);
          fbb.startTable(5);
          fbb.addInt64(0, object.id ?? 0);
          fbb.addOffset(1, nameOffset);
          fbb.addInt64(2, object.order);
          fbb.addBool(3, object.defaultCategory);
          fbb.finish(fbb.endTable());
          return object.id ?? 0;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = Category(
              id: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 4),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 6),
              order: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 8),
              defaultCategory: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 10));

          return object;
        }),
    Chapter: EntityDefinition<Chapter>(
        model: _entities[1],
        toOneRelations: (Chapter object) => [],
        toManyRelations: (Chapter object) => {},
        getId: (Chapter object) => object.id,
        setId: (Chapter object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Chapter.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Chapter object, fb.Builder fbb) {
          final nameOffset =
              object.name == null ? null : fbb.writeString(object.name!);
          final scanlatorOffset = object.scanlator == null
              ? null
              : fbb.writeString(object.scanlator!);
          final urlOffset =
              object.url == null ? null : fbb.writeString(object.url!);
          fbb.startTable(18);
          fbb.addInt64(0, object.id ?? 0);
          fbb.addBool(1, object.bookmarked);
          fbb.addInt64(2, object.chapterCount);
          fbb.addInt64(3, object.chapterNumber);
          fbb.addBool(4, object.downloaded);
          fbb.addInt64(5, object.fetchedAt);
          fbb.addInt64(6, object.index);
          fbb.addBool(7, object.markPrevRead);
          fbb.addInt64(8, object.lastPageRead);
          fbb.addInt64(9, object.lastReadAt);
          fbb.addInt64(10, object.mangaId);
          fbb.addOffset(11, nameOffset);
          fbb.addInt64(12, object.pageCount);
          fbb.addBool(13, object.read);
          fbb.addOffset(14, scanlatorOffset);
          fbb.addInt64(15, object.uploadDate);
          fbb.addOffset(16, urlOffset);
          fbb.finish(fbb.endTable());
          return object.id ?? 0;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = Chapter(
              id: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 4),
              bookmarked: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 6),
              chapterCount: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 8),
              chapterNumber: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 10),
              downloaded: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 12),
              fetchedAt: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 14),
              index: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 16),
              markPrevRead: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 18),
              lastPageRead: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 20),
              lastReadAt: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 22),
              mangaId: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 24),
              name: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 26),
              pageCount: const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 28),
              read: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 30),
              scanlator: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 32),
              uploadDate: const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 34),
              url: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 36));

          return object;
        }),
    Extension: EntityDefinition<Extension>(
        model: _entities[2],
        toOneRelations: (Extension object) => [],
        toManyRelations: (Extension object) => {},
        getId: (Extension object) => object.id,
        setId: (Extension object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Extension.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Extension object, fb.Builder fbb) {
          final apkNameOffset =
              object.apkName == null ? null : fbb.writeString(object.apkName!);
          final iconUrlOffset =
              object.iconUrl == null ? null : fbb.writeString(object.iconUrl!);
          final nameOffset =
              object.name == null ? null : fbb.writeString(object.name!);
          final pkgNameOffset =
              object.pkgName == null ? null : fbb.writeString(object.pkgName!);
          final versionNameOffset = object.versionName == null
              ? null
              : fbb.writeString(object.versionName!);
          final langOffset =
              object.lang == null ? null : fbb.writeString(object.lang!);
          fbb.startTable(13);
          fbb.addInt64(0, object.id ?? 0);
          fbb.addOffset(1, apkNameOffset);
          fbb.addOffset(2, iconUrlOffset);
          fbb.addOffset(3, nameOffset);
          fbb.addOffset(4, pkgNameOffset);
          fbb.addOffset(5, versionNameOffset);
          fbb.addInt64(6, object.versionCode);
          fbb.addOffset(7, langOffset);
          fbb.addBool(8, object.isNsfw);
          fbb.addBool(9, object.installed);
          fbb.addBool(10, object.hasUpdate);
          fbb.addBool(11, object.obsolete);
          fbb.finish(fbb.endTable());
          return object.id ?? 0;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = Extension(
              id: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 4),
              apkName: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 6),
              iconUrl: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 8),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 10),
              pkgName: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 12),
              versionName: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 14),
              versionCode: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 16),
              lang: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 18),
              isNsfw: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 20),
              installed: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 22),
              hasUpdate: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 24),
              obsolete: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 26));

          return object;
        }),
    Manga: EntityDefinition<Manga>(
        model: _entities[3],
        toOneRelations: (Manga object) => [],
        toManyRelations: (Manga object) => {},
        getId: (Manga object) => object.id,
        setId: (Manga object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Manga.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Manga object, fb.Builder fbb) {
          final artistOffset =
              object.artist == null ? null : fbb.writeString(object.artist!);
          final authorOffset =
              object.author == null ? null : fbb.writeString(object.author!);
          final descriptionOffset = object.description == null
              ? null
              : fbb.writeString(object.description!);
          final realUrlOffset =
              object.realUrl == null ? null : fbb.writeString(object.realUrl!);
          final sourceIdOffset = object.sourceId == null
              ? null
              : fbb.writeString(object.sourceId!);
          final statusOffset =
              object.status == null ? null : fbb.writeString(object.status!);
          final thumbnailUrlOffset = object.thumbnailUrl == null
              ? null
              : fbb.writeString(object.thumbnailUrl!);
          final titleOffset =
              object.title == null ? null : fbb.writeString(object.title!);
          final urlOffset =
              object.url == null ? null : fbb.writeString(object.url!);
          final genreOffset = object.genre == null
              ? null
              : fbb.writeList(
                  object.genre!.map(fbb.writeString).toList(growable: false));
          fbb.startTable(18);
          fbb.addOffset(0, artistOffset);
          fbb.addOffset(1, authorOffset);
          fbb.addOffset(2, descriptionOffset);
          fbb.addInt64(3, object.downloadCount);
          fbb.addBool(4, object.freshData);
          fbb.addInt64(5, object.id ?? 0);
          fbb.addBool(6, object.inLibrary);
          fbb.addInt64(7, object.inLibraryAt);
          fbb.addBool(8, object.initialized);
          fbb.addOffset(9, realUrlOffset);
          fbb.addOffset(10, sourceIdOffset);
          fbb.addOffset(11, statusOffset);
          fbb.addOffset(12, thumbnailUrlOffset);
          fbb.addOffset(13, titleOffset);
          fbb.addInt64(14, object.unreadCount);
          fbb.addOffset(15, urlOffset);
          fbb.addOffset(16, genreOffset);
          fbb.finish(fbb.endTable());
          return object.id ?? 0;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = Manga(
              artist: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 4),
              author: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 6),
              description: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 8),
              downloadCount: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 10),
              freshData: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 12),
              genre: const fb.ListReader<String>(
                      fb.StringReader(asciiOptimization: true),
                      lazy: false)
                  .vTableGetNullable(buffer, rootOffset, 36),
              id: const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 14),
              inLibrary: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 16),
              inLibraryAt: const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 18),
              initialized: const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 20),
              realUrl: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 22),
              sourceId: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 24),
              status: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 26),
              thumbnailUrl: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 28),
              title: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 30),
              unreadCount: const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 32),
              url: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 34));

          return object;
        }),
    MangaChapterRelation: EntityDefinition<MangaChapterRelation>(
        model: _entities[4],
        toOneRelations: (MangaChapterRelation object) => [object.manga],
        toManyRelations: (MangaChapterRelation object) => {
              RelInfo<MangaChapterRelation>.toMany(1, object.id):
                  object.chapters
            },
        getId: (MangaChapterRelation object) => object.id,
        setId: (MangaChapterRelation object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field MangaChapterRelation.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (MangaChapterRelation object, fb.Builder fbb) {
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addInt64(1, object.manga.targetId);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = MangaChapterRelation(
              id: const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0),
              manga: ToOne(
                  targetId: const fb.Int64Reader()
                      .vTableGet(buffer, rootOffset, 6, 0)),
              chapters: ToMany());
          object.manga.attach(store);
          InternalToManyAccess.setRelInfo(
              object.chapters,
              store,
              RelInfo<MangaChapterRelation>.toMany(1, object.id),
              store.box<MangaChapterRelation>());
          return object;
        }),
    Source: EntityDefinition<Source>(
        model: _entities[5],
        toOneRelations: (Source object) => [],
        toManyRelations: (Source object) => {},
        getId: (Source object) => object.intId,
        setId: (Source object, int id) {
          if (object.intId != id) {
            throw ArgumentError('Field Source.intId is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.intId=${object.intId}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Source object, fb.Builder fbb) {
          final idOffset =
              object.id == null ? null : fbb.writeString(object.id!);
          final nameOffset =
              object.name == null ? null : fbb.writeString(object.name!);
          final langOffset =
              object.lang == null ? null : fbb.writeString(object.lang!);
          final iconUrlOffset =
              object.iconUrl == null ? null : fbb.writeString(object.iconUrl!);
          final displayNameOffset = object.displayName == null
              ? null
              : fbb.writeString(object.displayName!);
          fbb.startTable(10);
          fbb.addInt64(0, object.intId ?? 0);
          fbb.addOffset(1, idOffset);
          fbb.addOffset(2, nameOffset);
          fbb.addOffset(3, langOffset);
          fbb.addOffset(4, iconUrlOffset);
          fbb.addBool(5, object.supportsLatest);
          fbb.addBool(6, object.isConfigurable);
          fbb.addBool(7, object.isNsfw);
          fbb.addOffset(8, displayNameOffset);
          fbb.finish(fbb.endTable());
          return object.intId ?? 0;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);

          final object = Source(
              intId: const fb.Int64Reader()
                  .vTableGetNullable(buffer, rootOffset, 4),
              id: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 6),
              name: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 8),
              lang: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 10),
              iconUrl: const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 12),
              supportsLatest: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 14),
              isConfigurable: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 16),
              isNsfw: const fb.BoolReader()
                  .vTableGetNullable(buffer, rootOffset, 18),
              displayName: const fb.StringReader(asciiOptimization: true).vTableGetNullable(buffer, rootOffset, 20));

          return object;
        })
  };

  return ModelDefinition(model, bindings);
}

/// [Category] entity fields to define ObjectBox queries.
class Category_ {
  /// see [Category.id]
  static final id = QueryIntegerProperty<Category>(_entities[0].properties[0]);

  /// see [Category.name]
  static final name = QueryStringProperty<Category>(_entities[0].properties[1]);

  /// see [Category.order]
  static final order =
      QueryIntegerProperty<Category>(_entities[0].properties[2]);

  /// see [Category.defaultCategory]
  static final defaultCategory =
      QueryBooleanProperty<Category>(_entities[0].properties[3]);
}

/// [Chapter] entity fields to define ObjectBox queries.
class Chapter_ {
  /// see [Chapter.id]
  static final id = QueryIntegerProperty<Chapter>(_entities[1].properties[0]);

  /// see [Chapter.bookmarked]
  static final bookmarked =
      QueryBooleanProperty<Chapter>(_entities[1].properties[1]);

  /// see [Chapter.chapterCount]
  static final chapterCount =
      QueryIntegerProperty<Chapter>(_entities[1].properties[2]);

  /// see [Chapter.chapterNumber]
  static final chapterNumber =
      QueryIntegerProperty<Chapter>(_entities[1].properties[3]);

  /// see [Chapter.downloaded]
  static final downloaded =
      QueryBooleanProperty<Chapter>(_entities[1].properties[4]);

  /// see [Chapter.fetchedAt]
  static final fetchedAt =
      QueryIntegerProperty<Chapter>(_entities[1].properties[5]);

  /// see [Chapter.index]
  static final index =
      QueryIntegerProperty<Chapter>(_entities[1].properties[6]);

  /// see [Chapter.markPrevRead]
  static final markPrevRead =
      QueryBooleanProperty<Chapter>(_entities[1].properties[7]);

  /// see [Chapter.lastPageRead]
  static final lastPageRead =
      QueryIntegerProperty<Chapter>(_entities[1].properties[8]);

  /// see [Chapter.lastReadAt]
  static final lastReadAt =
      QueryIntegerProperty<Chapter>(_entities[1].properties[9]);

  /// see [Chapter.mangaId]
  static final mangaId =
      QueryIntegerProperty<Chapter>(_entities[1].properties[10]);

  /// see [Chapter.name]
  static final name = QueryStringProperty<Chapter>(_entities[1].properties[11]);

  /// see [Chapter.pageCount]
  static final pageCount =
      QueryIntegerProperty<Chapter>(_entities[1].properties[12]);

  /// see [Chapter.read]
  static final read =
      QueryBooleanProperty<Chapter>(_entities[1].properties[13]);

  /// see [Chapter.scanlator]
  static final scanlator =
      QueryStringProperty<Chapter>(_entities[1].properties[14]);

  /// see [Chapter.uploadDate]
  static final uploadDate =
      QueryIntegerProperty<Chapter>(_entities[1].properties[15]);

  /// see [Chapter.url]
  static final url = QueryStringProperty<Chapter>(_entities[1].properties[16]);
}

/// [Extension] entity fields to define ObjectBox queries.
class Extension_ {
  /// see [Extension.id]
  static final id = QueryIntegerProperty<Extension>(_entities[2].properties[0]);

  /// see [Extension.apkName]
  static final apkName =
      QueryStringProperty<Extension>(_entities[2].properties[1]);

  /// see [Extension.iconUrl]
  static final iconUrl =
      QueryStringProperty<Extension>(_entities[2].properties[2]);

  /// see [Extension.name]
  static final name =
      QueryStringProperty<Extension>(_entities[2].properties[3]);

  /// see [Extension.pkgName]
  static final pkgName =
      QueryStringProperty<Extension>(_entities[2].properties[4]);

  /// see [Extension.versionName]
  static final versionName =
      QueryStringProperty<Extension>(_entities[2].properties[5]);

  /// see [Extension.versionCode]
  static final versionCode =
      QueryIntegerProperty<Extension>(_entities[2].properties[6]);

  /// see [Extension.lang]
  static final lang =
      QueryStringProperty<Extension>(_entities[2].properties[7]);

  /// see [Extension.isNsfw]
  static final isNsfw =
      QueryBooleanProperty<Extension>(_entities[2].properties[8]);

  /// see [Extension.installed]
  static final installed =
      QueryBooleanProperty<Extension>(_entities[2].properties[9]);

  /// see [Extension.hasUpdate]
  static final hasUpdate =
      QueryBooleanProperty<Extension>(_entities[2].properties[10]);

  /// see [Extension.obsolete]
  static final obsolete =
      QueryBooleanProperty<Extension>(_entities[2].properties[11]);
}

/// [Manga] entity fields to define ObjectBox queries.
class Manga_ {
  /// see [Manga.artist]
  static final artist = QueryStringProperty<Manga>(_entities[3].properties[0]);

  /// see [Manga.author]
  static final author = QueryStringProperty<Manga>(_entities[3].properties[1]);

  /// see [Manga.description]
  static final description =
      QueryStringProperty<Manga>(_entities[3].properties[2]);

  /// see [Manga.downloadCount]
  static final downloadCount =
      QueryIntegerProperty<Manga>(_entities[3].properties[3]);

  /// see [Manga.freshData]
  static final freshData =
      QueryBooleanProperty<Manga>(_entities[3].properties[4]);

  /// see [Manga.id]
  static final id = QueryIntegerProperty<Manga>(_entities[3].properties[5]);

  /// see [Manga.inLibrary]
  static final inLibrary =
      QueryBooleanProperty<Manga>(_entities[3].properties[6]);

  /// see [Manga.inLibraryAt]
  static final inLibraryAt =
      QueryIntegerProperty<Manga>(_entities[3].properties[7]);

  /// see [Manga.initialized]
  static final initialized =
      QueryBooleanProperty<Manga>(_entities[3].properties[8]);

  /// see [Manga.realUrl]
  static final realUrl = QueryStringProperty<Manga>(_entities[3].properties[9]);

  /// see [Manga.sourceId]
  static final sourceId =
      QueryStringProperty<Manga>(_entities[3].properties[10]);

  /// see [Manga.status]
  static final status = QueryStringProperty<Manga>(_entities[3].properties[11]);

  /// see [Manga.thumbnailUrl]
  static final thumbnailUrl =
      QueryStringProperty<Manga>(_entities[3].properties[12]);

  /// see [Manga.title]
  static final title = QueryStringProperty<Manga>(_entities[3].properties[13]);

  /// see [Manga.unreadCount]
  static final unreadCount =
      QueryIntegerProperty<Manga>(_entities[3].properties[14]);

  /// see [Manga.url]
  static final url = QueryStringProperty<Manga>(_entities[3].properties[15]);

  /// see [Manga.genre]
  static final genre =
      QueryStringVectorProperty<Manga>(_entities[3].properties[16]);
}

/// [MangaChapterRelation] entity fields to define ObjectBox queries.
class MangaChapterRelation_ {
  /// see [MangaChapterRelation.id]
  static final id =
      QueryIntegerProperty<MangaChapterRelation>(_entities[4].properties[0]);

  /// see [MangaChapterRelation.manga]
  static final manga = QueryRelationToOne<MangaChapterRelation, Manga>(
      _entities[4].properties[1]);

  /// see [MangaChapterRelation.chapters]
  static final chapters = QueryRelationToMany<MangaChapterRelation, Chapter>(
      _entities[4].relations[0]);
}

/// [Source] entity fields to define ObjectBox queries.
class Source_ {
  /// see [Source.intId]
  static final intId = QueryIntegerProperty<Source>(_entities[5].properties[0]);

  /// see [Source.id]
  static final id = QueryStringProperty<Source>(_entities[5].properties[1]);

  /// see [Source.name]
  static final name = QueryStringProperty<Source>(_entities[5].properties[2]);

  /// see [Source.lang]
  static final lang = QueryStringProperty<Source>(_entities[5].properties[3]);

  /// see [Source.iconUrl]
  static final iconUrl =
      QueryStringProperty<Source>(_entities[5].properties[4]);

  /// see [Source.supportsLatest]
  static final supportsLatest =
      QueryBooleanProperty<Source>(_entities[5].properties[5]);

  /// see [Source.isConfigurable]
  static final isConfigurable =
      QueryBooleanProperty<Source>(_entities[5].properties[6]);

  /// see [Source.isNsfw]
  static final isNsfw =
      QueryBooleanProperty<Source>(_entities[5].properties[7]);

  /// see [Source.displayName]
  static final displayName =
      QueryStringProperty<Source>(_entities[5].properties[8]);
}
